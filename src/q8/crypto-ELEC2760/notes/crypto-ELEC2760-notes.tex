\documentclass[en]{../../../eplnotes}

\hypertitle{crypto-ELEC2760}{8}{3}{4}
{Author}
{Professor}

If 1 round, there is no diffusion, we can attack each S-box separately (only 8 bits).

If the same key for each round: Sliding atk

We try to find a collision where to check a collision, we need to break a single round.

p_0 -- R -- R -- R -- R -- ... -- R -- R -- R -- c_0
     p_1 -- R -- R -- R -- ...         -- R -- R -- R -- c_1

Il suffit de regarder la clef qui donne $R(c_0) = c_1$ (en cassant un single round
Et checker si $R(p_0) = p_1$, avec le birthday paradox, on est bon :)


besoin de confusion et diffusion pour m√©langer texte et clef


Even designers of AES do not know why they did the key scheduling the way they did it.

differential cryptanalysis est plus utile dans le cas de related keys, tout encrypter avec k1, k2 et k1+k2

new links between differential and Linear Cryptanalisis

AES a des soucis avec des related keys

Group: <G, +>
-> closed
-> associative
-> neutral
-> inverse
-> (commulative)

Field: <F, +, x>
- <F,+> additive group with neutral 0
- <F\0, x> multiplicative group with neutral 1

Crypto => finite fields
Theorem: FF of order m <=> m = p^n (where p is prime)

Extension fields (for efficiency)
a(x) = a_7 x^7 + a_6 x^6 + ... + a_1 x + a_0
-> polynomial with a_i in F(2)

Addition: a(x) + b(x)
Mult: a(x) + b(x) mod (n(x)
with n(x) = irreducible polynomial.

Not Markov since key schedule does not produce independent subkeys

lim
N_R (number of rounds) -> inf  LCB(Omega_max) = 0

lim_NR -> inf LB(a,b; K) \neq 0

If we iterate 2 8-bit Sbox, we won't get 2^{-6}, only 2^{-3}.
The iteration is to have like a 128-bit S-box

EDP(a,b)
= sum_p PR[p] Pr_X[p(x xor a) = p(x) xor b]
= sum_p Pr[p] sum_x Pr[x] 1_(p(x xor a) = p(x) xor b)
= 1/(2^n)! sum_x sum_x Pr[x] 1_(p(x xor a) = p(x) xor b)
= 1/(2^n)! sum_p 1_(p(x xor a) = p(x) xor b)
           --------------------------------
           = perms: x -> alpha
                    x xor a -> alpha xor b
-> 1/(2^n)! (2^n)!/(2^n-1) = 1/(2^n-1)


This is linear because multiplied with a constant
   03 x^3 +  01 x^2 +  01 x +  02
x a_3 x^3 + a_2 x^2 + a_1 x + a_0
= 3 a_3 x^6 + 3a_2x^5 + 3a_1 x^4 + 3 a_0 x^3
+ 1a_3 x^5 + 1 a_2 x^4 + 1 a_1 x^3 + 1a_0x^2
+ 1a_3 x^4 + 1 a_2 x^3 + 1 a_1 x^2 + 1 a_0 x
+ 2a_3 x^3 + 2 a_2 x^2 + 2 a_1 x   + 2a_0
= 3a_0 x^2 + 3 a_2 x   + 3 a_1     + 3a_0x^3
+ 1a_3x + 1 a_2 + 1 a_1 x^3 + 1 a_1 x
+ 1 a_3 + 1 a_2x^3 + 1a_1x^2 + 11a_0x
+ 2a_3x^3 + 2a_2x^2 + 2a_1x + 2a_0

The only non-linear is the S-boxes and we try to make the most of them active

There is analysis for 4bit S-boxes ((2^4)! is small)
Not for 8bits S-boxes ((2^8)! is huge)

We are not in the field of provable security.

At the moment, nobody really knows how to do the key scheduling.
There are related key attacks.
  _   _
_| |_| |_...

_|\_|\

Sequential logic becomes difficult to do with very small circuits, asynchronious logic is being considered.
But it is a lot harder to implement.

When switching, there is a small time where the electrons can go through (short circuit) -> it is beta_sc

With very small circuits, physics make inter-device variability

Low cost design needs that the block cipher only have 1 S-box.
It is good for embedded device.

Pipelining cannot always be done, ECB ok but for CBC cannot do it because it needs the result of the previous for the next one.

Minimum memory cost of the first one: 2^8 x 8 = 2048
Minimum memory cost of the second one: (2^4 x 4) x 6 = 384


\end{document}
